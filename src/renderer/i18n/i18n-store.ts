import { create } from 'zustand';import { persist } from 'zustand/middleware';import { translations, Language, TranslationKeys } from './translations';type NestedKeyOf<ObjectType extends object> = {  [Key in keyof ObjectType & (string | number)]: ObjectType[Key] extends object    ? `${Key}` | `${Key}.${NestedKeyOf<ObjectType[Key]>}`    : `${Key}`;}[keyof ObjectType & (string | number)];export type TranslationKey = NestedKeyOf<TranslationKeys>;interface I18nState {  language: Language;  setLanguage: (language: Language) => void;  t: (key: string) => string;}function getNestedValue(obj: Record<string, unknown>, path: string): string {  const keys = path.split('.');  let result: unknown = obj;  for (const key of keys) {    if (result && typeof result === 'object' && key in result) {      result = (result as Record<string, unknown>)[key];    } else {      return path;     }  }  return typeof result === 'string' ? result : path;}export const useI18n = create<I18nState>()(  persist(    (set, get) => ({      language: 'es',       setLanguage: (language: Language) => {        set({ language });        if (typeof document !== 'undefined') {          document.documentElement.lang = language;        }      },      t: (key: string): string => {        const { language } = get();        const currentTranslations = translations[language];        return getNestedValue(currentTranslations, key);      },    }),    {      name: 'replicon-language',      partialize: (state) => ({ language: state.language }),    }  ));export function useTranslation() {  const { language, setLanguage, t } = useI18n();  return {    language,    setLanguage,    t,    isSpanish: language === 'es',    isEnglish: language === 'en',  };}export function getTranslation(key: string): string {  return useI18n.getState().t(key);}export function getCurrentLanguage(): Language {  return useI18n.getState().language;}