import { create } from 'zustand';import type { CSVRow } from '@shared/types';interface CSVHistoryState {  past: CSVRow[][];  future: CSVRow[][];  current: CSVRow[] | null;  maxHistory: number;  pushState: (newState: CSVRow[]) => void;  initialize: (state: CSVRow[] | null) => void;  undo: () => CSVRow[] | null;  redo: () => CSVRow[] | null;  canUndo: () => boolean;  canRedo: () => boolean;  clearHistory: () => void;  getHistoryInfo: () => { undoSteps: number; redoSteps: number };}export const useCSVHistoryStore = create<CSVHistoryState>((set, get) => ({  past: [],  future: [],  current: null,  maxHistory: 50,  pushState: (newState: CSVRow[]) => {    const { current, past, maxHistory } = get();    if (current !== null) {      const newPast = [...past, current];      if (newPast.length > maxHistory) {        newPast.shift();      }      set({        past: newPast,        current: newState,        future: [],       });    } else {      set({ current: newState, future: [] });    }  },  initialize: (state: CSVRow[] | null) => {    set({      current: state,      past: [],      future: [],    });  },  undo: () => {    const { past, current, future } = get();    if (past.length === 0) return null;    const newPast = [...past];    const previous = newPast.pop();    if (!previous) return null;    set({      past: newPast,      current: previous,      future: current ? [current, ...future] : future,    });    return previous;  },  redo: () => {    const { past, current, future } = get();    if (future.length === 0) return null;    const [next, ...newFuture] = future;    set({      past: current ? [...past, current] : past,      current: next,      future: newFuture,    });    return next;  },  canUndo: () => {    return get().past.length > 0;  },  canRedo: () => {    return get().future.length > 0;  },  clearHistory: () => {    set({      past: [],      future: [],    });  },  getHistoryInfo: () => {    const { past, future } = get();    return {      undoSteps: past.length,      redoSteps: future.length,    };  },}));