import Store from 'electron-store';const store = new Store();export type Language = 'en' | 'es';const translations = {  en: {    common: {      cancel: 'Cancel',    },    updates: {      available: 'üîÑ Update Available',      availableDesc: 'New version {{version}} available. Click to download.',      ready: '‚úÖ Update Ready',      readyDesc: 'Version {{version}} downloaded. Click to install.',      downloading: '‚¨áÔ∏è Downloading',      downloadingDesc: 'Downloading update in background...',      downloadError: '‚ùå Download Error',      downloadErrorDesc: 'Could not download the update.',      installTitle: 'Update Ready',      installMessage: 'Version {{version}} downloaded',      installDetail: 'The update will be installed when the application restarts.\n\nDo you want to restart now?',      restartNow: 'Restart Now',      later: 'Later',      availableTitle: 'Update Available',      availableMessage: 'New version {{version}} available',      availableDetail: 'Current version: {{currentVersion}}\n\nDo you want to download the update now?',      download: 'Download',      checkError: '‚ùå Error',      checkErrorDesc: 'Could not check for updates. Verify your connection.',      installBeforeQuit: 'Update Pending',      installBeforeQuitMessage: 'Version {{version}} is ready to install',      installBeforeQuitDetail: 'Do you want to install the update before closing?',      installAndQuit: 'Install and Close',      quitWithoutUpdate: 'Close Without Updating',    },    automation: {      started: 'üöÄ Automation Started',      startedDesc: 'Processing {{count}} rows',      completed: '‚úÖ Automation Completed',      completedDesc: 'Successfully processed {{count}} rows',      error: '‚ùå Automation Error',      errorDesc: 'An error occurred during automation',      paused: '‚è∏Ô∏è Automation Paused',      pausedDesc: 'Automation has been paused',      resumed: '‚ñ∂Ô∏è Automation Resumed',      resumedDesc: 'Automation has been resumed',    },    errors: {      generic: 'An error occurred',      network: 'Network error',      timeout: 'Operation timed out',    },  },  es: {    common: {      cancel: 'Cancelar',    },    updates: {      available: 'üîÑ Actualizaci√≥n Disponible',      availableDesc: 'Nueva versi√≥n {{version}} disponible. Click para descargar.',      ready: '‚úÖ Actualizaci√≥n Lista',      readyDesc: 'Versi√≥n {{version}} descargada. Click para instalar.',      downloading: '‚¨áÔ∏è Descargando',      downloadingDesc: 'Descargando actualizaci√≥n en segundo plano...',      downloadError: '‚ùå Error de Descarga',      downloadErrorDesc: 'No se pudo descargar la actualizaci√≥n.',      installTitle: 'Actualizaci√≥n Lista',      installMessage: 'Versi√≥n {{version}} descargada',      installDetail: 'La actualizaci√≥n se instalar√° al reiniciar la aplicaci√≥n.\n\n¬øDeseas reiniciar ahora?',      restartNow: 'Reiniciar Ahora',      later: 'M√°s tarde',      availableTitle: 'Actualizaci√≥n Disponible',      availableMessage: 'Nueva versi√≥n {{version}} disponible',      availableDetail: 'Versi√≥n actual: {{currentVersion}}\n\n¬øDeseas descargar la actualizaci√≥n ahora?',      download: 'Descargar',      checkError: '‚ùå Error',      checkErrorDesc: 'No se pudo verificar actualizaciones. Verifica tu conexi√≥n.',      installBeforeQuit: 'Actualizaci√≥n Pendiente',      installBeforeQuitMessage: 'La versi√≥n {{version}} est√° lista para instalar',      installBeforeQuitDetail: '¬øDeseas instalar la actualizaci√≥n antes de cerrar?',      installAndQuit: 'Instalar y Cerrar',      quitWithoutUpdate: 'Cerrar Sin Actualizar',    },    automation: {      started: 'üöÄ Automatizaci√≥n Iniciada',      startedDesc: 'Procesando {{count}} filas',      completed: '‚úÖ Automatizaci√≥n Completada',      completedDesc: 'Se procesaron {{count}} filas exitosamente',      error: '‚ùå Error de Automatizaci√≥n',      errorDesc: 'Ocurri√≥ un error durante la automatizaci√≥n',      paused: '‚è∏Ô∏è Automatizaci√≥n Pausada',      pausedDesc: 'La automatizaci√≥n ha sido pausada',      resumed: '‚ñ∂Ô∏è Automatizaci√≥n Reanudada',      resumedDesc: 'La automatizaci√≥n ha sido reanudada',    },    errors: {      generic: 'Ocurri√≥ un error',      network: 'Error de red',      timeout: 'La operaci√≥n expir√≥',    },  },} as const;type TranslationKeys = typeof translations.en;function getCurrentLanguage(): Language {  const config = store.get('config') as { language?: string } | undefined;  return (config?.language as Language) || 'es';}function interpolate(text: string, vars?: Record<string, string | number>): string {  if (!vars) return text;  return Object.entries(vars).reduce((result, [key, value]) => {    return result.replace(new RegExp(`{{${key}}}`, 'g'), String(value));  }, text);}export function t(keyPath: string, vars?: Record<string, string | number>): string {  const lang = getCurrentLanguage();  const keys = keyPath.split('.');  let value: any = translations[lang];  for (const key of keys) {    if (value && typeof value === 'object' && key in value) {      value = value[key];    } else {      value = translations.en;      for (const k of keys) {        if (value && typeof value === 'object' && k in value) {          value = value[k];        } else {          return keyPath;         }      }      break;    }  }  if (typeof value === 'string') {    return interpolate(value, vars);  }  return keyPath;}export function getSection(section: string): Record<string, string> {  const lang = getCurrentLanguage();  const sectionData = translations[lang][section as keyof typeof translations.en];  return sectionData as unknown as Record<string, string>;}export { getCurrentLanguage };