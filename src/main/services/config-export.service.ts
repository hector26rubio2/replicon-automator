import { app } from 'electron';import { writeFile, readFile, mkdir } from 'fs/promises';import { existsSync } from 'fs';import path from 'path';import type { AppConfig, TimeSlot, AccountMappings } from '../../shared/types';export interface ExportableConfig {  version: string;  exportDate: string;  appConfig: AppConfig;  horarios: TimeSlot[];  mappings: AccountMappings;}export interface ImportResult {  success: boolean;  message: string;  config?: ExportableConfig;}const CONFIG_VERSION = '1.0.0';export async function exportConfig(  config: Omit<ExportableConfig, 'version' | 'exportDate'>,  filePath: string): Promise<{ success: boolean; message: string }> {  try {    const exportData: ExportableConfig = {      version: CONFIG_VERSION,      exportDate: new Date().toISOString(),      ...config,    };    const json = JSON.stringify(exportData, null, 2);    await writeFile(filePath, json, 'utf-8');    return { success: true, message: 'Configuraci贸n exportada correctamente' };  } catch (error) {    const message = error instanceof Error ? error.message : 'Error desconocido';    return { success: false, message: `Error al exportar: ${message}` };  }}export async function importConfig(filePath: string): Promise<ImportResult> {  try {    const content = await readFile(filePath, 'utf-8');    const data = JSON.parse(content);    if (!data.version || !data.appConfig || !data.horarios || !data.mappings) {      return {        success: false,        message: 'El archivo no tiene el formato correcto de configuraci贸n',      };    }    const [major] = data.version.split('.');    const [currentMajor] = CONFIG_VERSION.split('.');    if (major !== currentMajor) {      return {        success: false,        message: `Versi贸n incompatible: ${data.version}. Se requiere v${CONFIG_VERSION}`,      };    }    return {      success: true,      message: 'Configuraci贸n importada correctamente',      config: data as ExportableConfig,    };  } catch (error) {    const message = error instanceof Error ? error.message : 'Error desconocido';    return { success: false, message: `Error al importar: ${message}` };  }}export async function createAutoBackup(  config: Omit<ExportableConfig, 'version' | 'exportDate'>): Promise<string | null> {  try {    const backupDir = path.join(app.getPath('userData'), 'backups');    if (!existsSync(backupDir)) {      await mkdir(backupDir, { recursive: true });    }    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');    const backupPath = path.join(backupDir, `backup-${timestamp}.json`);    const result = await exportConfig(config, backupPath);    if (result.success) {      await cleanOldBackups(backupDir, 10);      return backupPath;    }    return null;  } catch {    return null;  }}async function cleanOldBackups(dir: string, keep: number): Promise<void> {  try {    const { readdir, unlink, stat } = await import('fs/promises');    const files = await readdir(dir);    const backups = await Promise.all(      files        .filter((f) => f.startsWith('backup-') && f.endsWith('.json'))        .map(async (f) => {          const filePath = path.join(dir, f);          const stats = await stat(filePath);          return { path: filePath, mtime: stats.mtime.getTime() };        })    );    backups.sort((a, b) => b.mtime - a.mtime);    const toDelete = backups.slice(keep);    await Promise.all(toDelete.map((b) => unlink(b.path)));  } catch {  }}export async function listBackups(): Promise<Array<{ path: string; date: Date }>> {  try {    const { readdir, stat } = await import('fs/promises');    const backupDir = path.join(app.getPath('userData'), 'backups');    if (!existsSync(backupDir)) return [];    const files = await readdir(backupDir);    const backups = await Promise.all(      files        .filter((f) => f.startsWith('backup-') && f.endsWith('.json'))        .map(async (f) => {          const filePath = path.join(backupDir, f);          const stats = await stat(filePath);          return { path: filePath, date: stats.mtime };        })    );    return backups.sort((a, b) => b.date.getTime() - a.date.getTime());  } catch {    return [];  }}